from itertools import combinations,permutations

import bisect
import heapq

range(10)
c=heapq.heapify(list(range(10)))

s="$¢£¥€¤"
for i in s:
	print (ord(i),end=" ")

x="m d da"
duymy=[x for x in 'ABC']
print (x)
print (duymy)


def png(k,c):
	if k==0:
		return k

cc=[]

# from xlwt import Workbook
# a=Workbook()
# c=a.add_sheet("d")
# print (dir(c))

c="%d%d"%(10,20)
# a=["%d%d"(%10,%20)]
# print (c)

total=treedeep**(treewide)
d=[]
d=[]
def tree_recursion(high,wide):
	"my not intelligent head" 







def deep_first(a,b,c=2,cc=3):#deep_first print this code is buggy need  to modify
	global d,treewide,treedeep,total
	if b==0 and a!=0:
		d+=[a]
		total-=1
	elif b!=0 and a==0:
		d+=deep_first(d,2)
	elif b!=0 and a!=0:
		d+=[a]
	elif b==0 and a==0:
		d+=[a]
		if total!=0:

def wide_first(a,b,c=2,d=3):#widefirst print this code is buggy need  to modify
	if b==0 and a==0:
		print (a)
	wide_first(a-1,b+1)
	wide_first(a+1,b-1)

old=0.43*1+0.21*2+0.12*2+0.24*2










portion_a1=21.5/78.5
portion_a2=21/78.5
portion_a3=12/78.5
portion_a4=24/78.5

a,b,c,d=1,2,2,2

print (a*portion_a1+b*portion_a2+c*portion_a3+d*portion_a4)
new=a*portion_a1+b*portion_a2+c*portion_a3+d*portion_a4


frequency=50

print (50/old)

print (50/new)


"对称树自顶向下"
"对称树自底向上"
